// This file is autogenerated by the hyperschema compiler
// Schema Version: 1

const { c } = require('hyperschema/runtime');

const VERSION = 1;

let version = VERSION;

// @wdk-secret-manager/command-workletStart-request
const encoding0 = {
  preencode(state, m) {
    state.end++; // max flag is 1 so always one byte

    if (m.enableDebugLogs) c.uint.preencode(state, m.enableDebugLogs);
  },
  encode(state, m) {
    const flags = m.enableDebugLogs ? 1 : 0;

    c.uint.encode(state, flags);

    if (m.enableDebugLogs) c.uint.encode(state, m.enableDebugLogs);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      enableDebugLogs: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
    };
  },
};

// @wdk-secret-manager/command-workletStart-response
const encoding1 = {
  preencode(state, m) {
    state.end++; // max flag is 1 so always one byte

    if (m.status) c.string.preencode(state, m.status);
  },
  encode(state, m) {
    const flags = m.status ? 1 : 0;

    c.uint.encode(state, flags);

    if (m.status) c.string.encode(state, m.status);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      status: (flags & 1) !== 0 ? c.string.decode(state) : null,
    };
  },
};

// @wdk-secret-manager/command-workletStop-request
const encoding2 = {
  preencode(state, m) {
    state.end++; // max flag is 1 so always one byte

    if (m.payload) c.string.preencode(state, m.payload);
  },
  encode(state, m) {
    const flags = m.payload ? 1 : 0;

    c.uint.encode(state, flags);

    if (m.payload) c.string.encode(state, m.payload);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      payload: (flags & 1) !== 0 ? c.string.decode(state) : null,
    };
  },
};

// @wdk-secret-manager/command-workletStop-response
const encoding3 = encoding1;

// @wdk-secret-manager/command-generateAndEncrypt-request
const encoding4 = {
  preencode(state, m) {
    state.end++; // max flag is 8 so always one byte

    if (m.passkey) c.string.preencode(state, m.passkey);
    if (m.salt) c.string.preencode(state, m.salt);
    if (m.seedPhrase) c.string.preencode(state, m.seedPhrase);
    if (m.derivedKey) c.string.preencode(state, m.derivedKey);
  },
  encode(state, m) {
    const flags =
      (m.passkey ? 1 : 0) | (m.salt ? 2 : 0) | (m.seedPhrase ? 4 : 0) | (m.derivedKey ? 8 : 0);

    c.uint.encode(state, flags);

    if (m.passkey) c.string.encode(state, m.passkey);
    if (m.salt) c.string.encode(state, m.salt);
    if (m.seedPhrase) c.string.encode(state, m.seedPhrase);
    if (m.derivedKey) c.string.encode(state, m.derivedKey);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      passkey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      salt: (flags & 2) !== 0 ? c.string.decode(state) : null,
      seedPhrase: (flags & 4) !== 0 ? c.string.decode(state) : null,
      derivedKey: (flags & 8) !== 0 ? c.string.decode(state) : null,
    };
  },
};

// @wdk-secret-manager/command-generateAndEncrypt-response
const encoding5 = {
  preencode(state, m) {
    state.end++; // max flag is 2 so always one byte

    if (m.encryptedEntropy) c.string.preencode(state, m.encryptedEntropy);
    if (m.encryptedSeed) c.string.preencode(state, m.encryptedSeed);
  },
  encode(state, m) {
    const flags = (m.encryptedEntropy ? 1 : 0) | (m.encryptedSeed ? 2 : 0);

    c.uint.encode(state, flags);

    if (m.encryptedEntropy) c.string.encode(state, m.encryptedEntropy);
    if (m.encryptedSeed) c.string.encode(state, m.encryptedSeed);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      encryptedEntropy: (flags & 1) !== 0 ? c.string.decode(state) : null,
      encryptedSeed: (flags & 2) !== 0 ? c.string.decode(state) : null,
    };
  },
};

// @wdk-secret-manager/command-decrypt-request
const encoding6 = {
  preencode(state, m) {
    state.end++; // max flag is 8 so always one byte

    if (m.passkey) c.string.preencode(state, m.passkey);
    if (m.salt) c.string.preencode(state, m.salt);
    if (m.encryptedData) c.string.preencode(state, m.encryptedData);
    if (m.derivedKey) c.string.preencode(state, m.derivedKey);
  },
  encode(state, m) {
    const flags =
      (m.passkey ? 1 : 0) | (m.salt ? 2 : 0) | (m.encryptedData ? 4 : 0) | (m.derivedKey ? 8 : 0);

    c.uint.encode(state, flags);

    if (m.passkey) c.string.encode(state, m.passkey);
    if (m.salt) c.string.encode(state, m.salt);
    if (m.encryptedData) c.string.encode(state, m.encryptedData);
    if (m.derivedKey) c.string.encode(state, m.derivedKey);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      passkey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      salt: (flags & 2) !== 0 ? c.string.decode(state) : null,
      encryptedData: (flags & 4) !== 0 ? c.string.decode(state) : null,
      derivedKey: (flags & 8) !== 0 ? c.string.decode(state) : null,
    };
  },
};

// @wdk-secret-manager/command-decrypt-response
const encoding7 = {
  preencode(state, m) {
    state.end++; // max flag is 1 so always one byte

    if (m.result) c.string.preencode(state, m.result);
  },
  encode(state, m) {
    const flags = m.result ? 1 : 0;

    c.uint.encode(state, flags);

    if (m.result) c.string.encode(state, m.result);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      result: (flags & 1) !== 0 ? c.string.decode(state) : null,
    };
  },
};

const encoding8_enum = {
  info: 1,
  error: 2,
  debug: 3,
};

// @wdk-secret-manager/log-type-enum enum
const encoding8 = {
  preencode(state, m) {
    state.end++; // max enum is 3 so always one byte
  },
  encode(state, m) {
    if (m > 3) throw new Error('Unknown enum');
    c.uint.encode(state, m);
  },
  decode(state) {
    return c.uint.decode(state);
  },
};

// @wdk-secret-manager/command-log-request
const encoding9 = {
  preencode(state, m) {
    state.end++; // max flag is 2 so always one byte

    if (m.type) encoding8.preencode(state, m.type);
    if (m.data) c.string.preencode(state, m.data);
  },
  encode(state, m) {
    const flags = (m.type ? 1 : 0) | (m.data ? 2 : 0);

    c.uint.encode(state, flags);

    if (m.type) encoding8.encode(state, m.type);
    if (m.data) c.string.encode(state, m.data);
  },
  decode(state) {
    const flags = c.uint.decode(state);

    return {
      type: (flags & 1) !== 0 ? encoding8.decode(state) : 0,
      data: (flags & 2) !== 0 ? c.string.decode(state) : null,
    };
  },
};

function setVersion(v) {
  version = v;
}

function encode(name, value, v = VERSION) {
  version = v;
  return c.encode(getEncoding(name), value);
}

function decode(name, buffer, v = VERSION) {
  version = v;
  return c.decode(getEncoding(name), buffer);
}

function getEnum(name) {
  switch (name) {
    case '@wdk-secret-manager/log-type-enum':
      return encoding8_enum;
    default:
      throw new Error('Enum not found ' + name);
  }
}

function getEncoding(name) {
  switch (name) {
    case '@wdk-secret-manager/command-workletStart-request':
      return encoding0;
    case '@wdk-secret-manager/command-workletStart-response':
      return encoding1;
    case '@wdk-secret-manager/command-workletStop-request':
      return encoding2;
    case '@wdk-secret-manager/command-workletStop-response':
      return encoding3;
    case '@wdk-secret-manager/command-generateAndEncrypt-request':
      return encoding4;
    case '@wdk-secret-manager/command-generateAndEncrypt-response':
      return encoding5;
    case '@wdk-secret-manager/command-decrypt-request':
      return encoding6;
    case '@wdk-secret-manager/command-decrypt-response':
      return encoding7;
    case '@wdk-secret-manager/log-type-enum':
      return encoding8;
    case '@wdk-secret-manager/command-log-request':
      return encoding9;
    default:
      throw new Error('Encoder not found ' + name);
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name);
  return {
    preencode(state, m) {
      version = v;
      enc.preencode(state, m);
    },
    encode(state, m) {
      version = v;
      enc.encode(state, m);
    },
    decode(state) {
      version = v;
      return enc.decode(state);
    },
  };
}

const resolveStruct = getStruct; // compat

module.exports = {
  resolveStruct,
  getStruct,
  getEnum,
  getEncoding,
  encode,
  decode,
  setVersion,
  version,
};
